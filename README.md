# Task 2
Simulating mutations and testing variant callers.

## Part 1: Validating Data

### Making Mutations:
mutations.py contains a function called mutations(), which takes in a .fasta file filename e.g. mutations('name.fasta') and outputs both a change log and a mutated genome in .txt format.

The function works broadly by first performing deletions, then insertions, and then single nucleotide polymorphisms (SNPs). Throughout the function, a 'mutation pool' is maintained which includes all available nucleotides for mutation (those which have not already been inserted, deleted, or SNPed). To do this, a 'reference index' is established, labelling all characters in the input sequence from 1 onwards. During deletion, the index points corresponding to the deleted nucleotides are deleted from the index, and during insertion, a list of 0s matching the length of the insertion are inserted into the index. Before each transformation, a point for the INDEL/SNP is selection from the mutation pool, and in this way, each INDEL/SNP is distinct, and non-overlapping. SNPs are selected all at once, using random.sample() from the random package, which selects distinct samples to prevent a SNP occuring at the same point. 

The function begins by prepping the FASTA file, removing the ID header and \n newline characters to read in the sequence as string 'seq'. Each mutation made to the genome is recorded in a dictionary object 'change_log'.

#### Deletions:
Deletions are performed in a loop, interating for the number of deletions assigned in the beginning. In each iteration, a random point is selected from the reference index, and the index point of the selected point of deletion relative to the reference index is taken using .index(). While this seems redundant on the first loop, this is how the changelog remains consistent relative to the original sequence despite frameshift mutations.

A random deletion length is generated from 1-10bp, which is added to the index point previously selected to select a small section of the sequence to be deleted, called 'del_seq'. An if/else statement is included to check wether the deletion will overhang the end of the sequence. If this is the case, then the deletion will only occur until the end of the sequence, rather than the full deletion length. Finally, the changelog, sequence, and reference index are all updated.

#### Insertions:
The reference index is first filtered to remove all 0 points (which relate to previous insertions) to prevent overlapping insertions. A random length of 1-10bp in generated by randomly selecting a nucleotide using random.choice() from the random package in a loop, adding a nucelotide each time until the desired length is reached.

As before, a random point is selected, and the relative index point if extracted. The changelog and reference index is updated (by inserting list of 0s the length of mutation, at the mutation point), and sequence is inserted at the point selected.

#### SNPs:
As iterating over the genome 300 times would be computationally expensive, all 300 SNP nucleotides are chosen simultaneously from the (filtered so as to prevent SNPs of insertion seqeunces) reference index. Rather than looping through all 300 points and selecting a SNP for each nucleotide, 300 random bases are generated at once. These bases are then compared in a while loop/if statement combination, where SNPs are again randomly chosen if they are the same as the original nucleotide. The idea behind this is that there are fewer changes to be made to the sequence, as each time, you would expect only ~25% of SNPs to be the same as the orignal nucelotide. By only updating SNPs that match, and preventing for-loop iteration across the entire genome or across 300 nucleotides, this should run more efficiently.
The SNPs are then applied to the genome, and the change log is updated.

Finally, the mutated sequence and changelog are output. 

### Simulating Reads:
reads.py contains function reads(), which takes in a .txt file in fasta format, a desired read length, and a desired average depth, and will return a fastq file in .fq format. 

